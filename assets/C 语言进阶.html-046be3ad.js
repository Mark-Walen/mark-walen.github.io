import{_ as i,X as l,Y as a,a2 as e}from"./framework-a8949fcd.js";const d={},h=e('<h1 id="c-语言进阶" tabindex="-1"><a class="header-anchor" href="#c-语言进阶" aria-hidden="true">#</a> C 语言进阶</h1><h2 id="void-使用" tabindex="-1"><a class="header-anchor" href="#void-使用" aria-hidden="true">#</a> void 使用</h2><ol><li><code>void</code> 无类型，不可以通过 <code>void</code> 创建类型；</li><li>限定函数返回值，限定函数参数；</li><li><code>void *</code> 泛型指针。</li></ol><h2 id="sizeof-的使用" tabindex="-1"><a class="header-anchor" href="#sizeof-的使用" aria-hidden="true">#</a> sizeof 的使用</h2><ol><li><code>sizeof</code> 本质不是一个函数，是一个运算符；</li><li><code>sizeof</code> 的返回值是 <code>unsigned int</code>；</li><li>统计数组占用内存空间大小。</li></ol><h2 id="变量的修改" tabindex="-1"><a class="header-anchor" href="#变量的修改" aria-hidden="true">#</a> 变量的修改</h2><ol><li>直接修改；</li><li>间接修改（指针修改）；</li></ol><h2 id="内存分区" tabindex="-1"><a class="header-anchor" href="#内存分区" aria-hidden="true">#</a> 内存分区</h2><h3 id="运行前" tabindex="-1"><a class="header-anchor" href="#运行前" aria-hidden="true">#</a> 运行前</h3><ol><li>预处理：宏定义展开、头文件展开、条件编译，不会检查语法；</li><li>编译：检查语法，将预处理后文件编译生成汇编文件；</li><li>汇编：将汇编文件生成目标文件（二进制文件）；</li><li>链接：将目标文件链接为可执行程序。</li></ol><ul><li>代码区（只读）</li><li>数据区（全局变量、静态变量） <ul><li>data （数据已初始化）</li><li>bss （数据未初始化）</li><li>常量</li></ul></li></ul><h3 id="运行后" tabindex="-1"><a class="header-anchor" href="#运行后" aria-hidden="true">#</a> 运行后</h3><ol><li>代码区</li><li>数据区</li><li>栈区</li><li>堆区</li></ol><h2 id="全局变量和静态变量" tabindex="-1"><a class="header-anchor" href="#全局变量和静态变量" aria-hidden="true">#</a> 全局变量和静态变量</h2><h3 id="静态变量" tabindex="-1"><a class="header-anchor" href="#静态变量" aria-hidden="true">#</a> 静态变量</h3><ol><li>程序运行前分配内存；</li><li>生命周期在程序运行结束时死亡；</li><li>默认属于内部链接属性，在当前文件中使用</li></ol><h3 id="全局变量" tabindex="-1"><a class="header-anchor" href="#全局变量" aria-hidden="true">#</a> 全局变量</h3><ol><li>在 C 语言中，默认情况下，全局变量前加了关键字 extern；</li><li>属于外部属性；</li></ol><h2 id="const-修饰的变量" tabindex="-1"><a class="header-anchor" href="#const-修饰的变量" aria-hidden="true">#</a> const 修饰的变量</h2><ol><li>全局 const 修饰常量 <ol><li>直接修改：失败；</li><li>间接修改：语法通过，受常量区保护；</li></ol></li><li>局部 const 修饰常量 <ol><li>直接修改：失败；</li><li>间接修改：成功，因为放在栈上。</li></ol></li></ol><h2 id="字符串常量" tabindex="-1"><a class="header-anchor" href="#字符串常量" aria-hidden="true">#</a> 字符串常量</h2><ol><li>在 vs 下将相同的字符串常量看作是同一个；</li><li>对于字符串常量的修改结果是未定义的，vs 是不可以修改的。</li></ol><h2 id="一级指针易错点" tabindex="-1"><a class="header-anchor" href="#一级指针易错点" aria-hidden="true">#</a> 一级指针易错点</h2><ol><li>指针越界；</li><li>指针叠加会不断改变指针的指向，释放指针内存会出错，解决方案，利用临时指针；</li><li>返回局部变量地址；</li><li>同一块内存多次释放，不可以释放野指针，可以多次释放空指针。</li></ol><h2 id="一维数组" tabindex="-1"><a class="header-anchor" href="#一维数组" aria-hidden="true">#</a> 一维数组</h2><ol><li>一维数组的名称是不是指向第一个元素的指针? 除以下两种情况： <ol><li>对数组名称 <code>sizeof</code>;</li><li>对数组名称取地址，步长是整个数组长度。</li></ol></li><li>数组名是指针常量，指针的指向是不可以修改的，指针指向的值可以修改</li></ol><h2 id="二维数组" tabindex="-1"><a class="header-anchor" href="#二维数组" aria-hidden="true">#</a> 二维数组</h2><ol><li>一般情况下，指向第一行数组指针；</li></ol>',28),o=[h];function r(c,n){return l(),a("div",null,o)}const t=i(d,[["render",r],["__file","C 语言进阶.html.vue"]]);export{t as default};
