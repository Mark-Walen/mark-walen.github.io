import{_ as n,X as t,Y as s,a2 as o}from"./framework-a8949fcd.js";const r="/assets/audio_process_step-483b72e4.png",g="/assets/discrete_samples_representing_a_continuous_analogue_signal-cc294bee.png",a="/assets/recombination_of_unframed_iso_pdus-b20a5bea.png",e="/assets/fragmentation_creating_unframed_iso_pdus-b0b1eecb.png",i="/assets/reassembly_of_framed_iso_pdus-db9f5035.png",p="/assets/segmentation_creating_frame_iso_pdus-34428228.png",c={},d=o('<h2 id="基础" tabindex="-1"><a class="header-anchor" href="#基础" aria-hidden="true">#</a> 基础</h2><p>等时适配层（ISOAL）的主要目的，是解决在涉及音频设备的连接型与广播型等时通信中可能出现的潜在问题。 它也可能在等时通信的其他应用场景中发挥作用。</p><p>Nick Hunn 的著作 <em>Introducing Bluetooth LE Audio</em>（《蓝牙 LE 音频介绍》）第 5.2 节对该主题有详细阐述，推荐阅读。</p><p><strong>音频采样基础（Audio Sampling 101）</strong> 数字音频的工作原理是对模拟音频信号进行采样，并对采样后的音频应用编解码器（codec）进行压缩或其他处理，以便存储，或者在蓝牙 LE 音频的情况下进行传输。</p><p>在读取或接收编码后的数字音频数据时，流程则相反：使用编解码器对数据进行解码，生成一系列数字采样，然后利用这些数字采样（近似地）重现原始的模拟音频。</p><p>图 1.1 展示了采样、编码和传输音频信号的步骤，以及接收编码音频数据、解码并最终渲染音频的逆向步骤。</p><figure><img src="'+r+'" alt="音频处理步骤" tabindex="0" loading="lazy"><figcaption>图1.1 音频处理步骤</figcaption></figure><p>音频编解码器的一个关键目标是 <strong>减小音频数据的大小</strong>，以便能够在带宽有限（且宝贵！）的链路上高效传输。</p><p>采样的过程包括在固定时间间隔测量并记录信号的幅度。采样的频率称为 <strong>采样率（sample rate）</strong>。</p><p>图 1.2 中的垂直线表示对连续变化的音频信号（由曲线表示）进行的采样。这一系列采样点构成了原始模拟信号的近似表示。</p><p>采样越频繁（即采样率越高），这种近似就越接近原始信号。在反向处理以重建原始音频时，采样率越高，重建效果越好，感知的音质也越高。</p><p>采样的另一个维度是 <strong>位深（bit depth）</strong>。在采样时，信号的幅度需要用整数值表示。</p><p>一种方法是将可能的幅度值范围划分为 256 个离散幅度带，并用 0 到 255 之间的数字表示每个幅度带。在这种方案下，每个采样只需一个字节（8 位）即可记录采样幅度所属的幅度带，因此位深称为 <strong>8 位</strong>。</p><p>将可能的幅度范围划分为更多离散幅度带，可以提供更细粒度的采样值表示系统，从而潜在地提高音质。例如，<strong>24 位位深</strong>可以用 0 到 16,777,215 范围内的整数表示可能的幅度值范围。然而，每个采样需要 3 个字节，因此使用更高位深进行采样会产生三倍的数据量。</p><figure><img src="'+g+'" alt="离散采样表示连续的模拟信号" tabindex="0" loading="lazy"><figcaption>图 1.2 离散采样表示连续的模拟信号</figcaption></figure><h2 id="编解码器与帧-codecs-and-frames" tabindex="-1"><a class="header-anchor" href="#编解码器与帧-codecs-and-frames" aria-hidden="true">#</a> <strong>编解码器与帧（Codecs and Frames）</strong></h2><p>像 LC3 这样的编解码器（codec），用于蓝牙 LE 音频，可能将原始数字采样数据压缩到 <strong>不到原始大小的 25%</strong>（但请注意，实际压缩效果在很大程度上取决于原始音频内容）。这是一个非常显著的节省。</p><p>编解码器通常通过识别并利用一系列连续采样中的模式来工作。举一个非常简单的例子，仅用于说明这一原理：如果数据集中包含一连串 100 个采样值，且每个值都相同，例如 50，那么假设位深为 8 位，编解码器可能将其表示为两个字节 <code>[100, 50]</code>，而不是原来的 100 个字节 <code>[50, 50, 50..., 50]</code>。显然，为了让编解码器发挥作用，它需要分析和编码 <strong>整系列采样</strong>，而不是一次只处理一个采样（单个采样中几乎找不到模式！）。</p><p>编解码器一次分析的一组采样称为 <strong>帧（frame）</strong>。帧具有固定的持续时间，通常以毫秒为单位，并包含由采样率决定的若干采样。例如，当采样率为 44.1 kHz 时，<strong>10 毫秒的帧</strong>包含 4410 个采样。</p><p>不同的音频产品可能使用不同的帧持续时间，10 毫秒和 7.5 毫秒较为常见。当一个设备生成音频（源设备）使用某种帧持续时间，而另一个设备接收音频（接收设备）使用不同的帧持续时间时，就会出现需要解决的问题。这正是 <strong>等时适配层（ISOAL）</strong> 的作用所在。</p><p><strong>帧式（Framed）与非帧式（Unframed）</strong></p><p>当设备使用等时通信时，发送设备和接收设备使用的帧持续时间 <strong>不必相同</strong>。这会产生两种可能的情况：</p><ol><li>第一个设备使用的帧持续时间是另一个设备使用的帧持续时间的 <strong>整数倍</strong>。</li><li>第一个设备使用的帧持续时间 <strong>不是</strong> 另一个设备使用的帧持续时间的整数倍。</li></ol><p>在第一种情况下，较大帧持续时间与较小帧持续时间之间的关系很简单，将数据在两者之间转换是一个直接操作。在一个或多个必需的链路层 PDU 的负载中发送的数据称为 <strong>非帧式（unframed）</strong>，其中不包含用于支持帧持续时间适配的额外数据。</p><p>在第二种情况下，链路层 PDU 可能包含较大负载的一部分，同时附带简短的头字段，用于指示该部分是帧的 <strong>开始</strong>、<strong>延续</strong> 或 <strong>结束</strong>。这种格式的数据称为 <strong>帧式（framed）</strong>。</p><p>无论是 <strong>连接型等时 PDU（Connected Isochronous PDU）</strong> 还是 <strong>广播型等时 PDU（Broadcast Isochronous PDU）</strong>（由链路层定义），都包含一个称为 <strong>LLID</strong> 的字段。LLID 用于指示链路层 PDU 的负载是 <strong>帧式</strong> 还是 <strong>非帧式</strong> 数据。</p><p>ISOAL 根据从链路层接收到的数据是否帧式，应用不同的处理过程。同样，是否需要帧式处理也会影响 ISOAL 对从上层 SDU 接收到的数据进行处理，并传递给链路层以在链路层 ISO PDU 中传输的方式。</p><h2 id="分片与重组-fragmentation-and-recombination" tabindex="-1"><a class="header-anchor" href="#分片与重组-fragmentation-and-recombination" aria-hidden="true">#</a> <strong>分片与重组（Fragmentation and Recombination）</strong></h2><p>如果数据为 <strong>非帧式（unframed）</strong>，则重组过程会将一个或多个链路层 PDU 负载中包含的一个或多个片段，组合成 <strong>单个服务数据单元（Service Data Unit, SDU）</strong>。随后，ISOAL 将该 SDU 传递给上层。如图 3.1 所示。</p><figure><img src="'+a+'" alt="非帧式 ISO PDUs 的重组" tabindex="0" loading="lazy"><figcaption>图3.1 非帧式 ISO PDUs 的重组</figcaption></figure><p>当 <strong>上层 SDU 需要被拆分为更小的负载</strong> 以便在链路层 PDU 中传输，并且 <strong>不需要帧式处理</strong> 时，该过程称为 <strong>分片（fragmentation）</strong>。如图 3.2 所示。</p><figure><img src="'+e+'" alt="分片生成非帧式 ISO PDUs" tabindex="0" loading="lazy"><figcaption>分片生成非帧式 ISO PDUs</figcaption></figure><p>非帧式 PDU 包含一个头部，其中包含字段，用于指示其后的数据是 <strong>SDU 的开始</strong>、<strong>前一个 SDU 的延续</strong>，还是 <strong>该 SDU 的结束</strong>。</p><p>每个 PDU 只包含 <strong>单个非帧式 SDU 的一个片段</strong>。</p><h2 id="分段与重组-segmentation-and-reassembly" tabindex="-1"><a class="header-anchor" href="#分段与重组-segmentation-and-reassembly" aria-hidden="true">#</a> <strong>分段与重组（Segmentation and Reassembly）</strong></h2><p>如果数据为 <strong>帧式（framed）</strong>，则重组过程会将一个或多个链路层 PDU 负载中包含的一个或多个 <strong>分段（segment）</strong> 组合成 <strong>单个服务数据单元（Service Data Unit, SDU）</strong>。随后，ISOAL 将该 SDU 传递给上层。如图 4.1 所示。</p><figure><img src="'+i+'" alt="帧式 ISO PDU的重组" tabindex="0" loading="lazy"><figcaption>图4.1 帧式 ISO PDU的重组</figcaption></figure><p>当 <strong>上层 SDU 需要被拆分为更小的负载</strong> 以便在链路层 PDU 中传输，且 <strong>需要帧式处理</strong> 时，该过程称为 <strong>分段（segmentation）</strong>。如图 4.2 所示。</p><figure><img src="'+p+'" alt="分段生产帧式 ISO PDUs" tabindex="0" loading="lazy"><figcaption>分段生产帧式 ISO PDUs</figcaption></figure><p>帧式 PDU 中的每个分段都包含一个头部，其中包含字段，用于指示其后的数据是 <strong>SDU 的开始</strong>、<strong>前一个 SDU 的延续</strong>，还是 <strong>该 SDU 的结束</strong>，并且包含 <strong>时间偏移信息（timing offset information）</strong>。帧式 PDU 可以包含 <strong>同一 SDU 的多个片段</strong>。</p>',40),m=[d];function f(_,l){return t(),s("div",null,m)}const U=n(c,[["render",f],["__file","isoal.html.vue"]]);export{U as default};
