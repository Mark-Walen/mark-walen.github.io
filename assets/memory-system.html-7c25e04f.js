import{_ as l,X as e,Y as t,a2 as n,Z as s,$ as a}from"./framework-a8949fcd.js";const i="/assets/img/arm-v7/ch5/memory-map.png",p="/assets/img/arm-v7/ch5/code-region.png",c="/assets/img/arm-v7/ch5/internal-sram.png",o="/assets/img/arm-v7/ch5/internal-peripheral.png",r="/assets/img/arm-v7/ch5/default-memory-access-permission.png",m="/assets/img/arm-v7/ch5/default-memory-access-permission-2.png",d="/assets/img/arm-v7/ch5/bit-banding.png",u="/assets/img/arm-v7/ch5/write_data_to_bit_band_alias.png",h="/assets/img/arm-v7/ch5/write_data_to_bit_band_alias_assembly_view.png",g="/assets/img/arm-v7/ch5/read_data_from_bit_band.png",k="/assets/img/arm-v7/ch5/read_data_from_bit_band_assembly_view.png",x={},y=n('<h1 id="内存系统" tabindex="-1"><a class="header-anchor" href="#内存系统" aria-hidden="true">#</a> 内存系统</h1><h2 id="内存系统特征概览" tabindex="-1"><a class="header-anchor" href="#内存系统特征概览" aria-hidden="true">#</a> 内存系统特征概览</h2><ul><li>预定义内存映射</li><li>位带操作</li><li>非对齐访问</li><li>支持大小端配置</li></ul><h2 id="内存映射" tabindex="-1"><a class="header-anchor" href="#内存映射" aria-hidden="true">#</a> 内存映射</h2><p>预定义内存的好处：</p><ul><li>方便 CM3 单片机的移植；</li><li>允许厂商灵活分配地址存储空间。</li></ul><p>存储空间的一些位置用于调试组件等私有外设，这个地址段被称为“私有外设区”。私有外设区的组件包括 ：</p><ul><li>闪存地址重载及断点单元（FPB）</li><li>数据观察点单元（DWT）</li><li>仪器化跟踪宏单元（ITM）</li><li>嵌入式跟踪红单元（ETM）</li><li>跟踪端口接口单元（TPIU）</li><li>ROM 表</li></ul><figure><img src="'+i+'" alt="图 5.1 Cortex-M3 预定义的存储器映射" tabindex="0" loading="lazy"><figcaption>图 5.1 Cortex-M3 预定义的存储器映射</figcaption></figure><h3 id="代码区" tabindex="-1"><a class="header-anchor" href="#代码区" aria-hidden="true">#</a> 代码区</h3><p>CM3 的地址空间是 4GB, 程序可以在代码区，内部 SRAM 区以及外部 RAM 区中执行。但是因为<u>指令总线与数据总线是分开的</u>，最理想的是把<strong>程序放到代码区</strong>，从而使取指和数据访问各自使用自己的总线，并行不悖 。</p><figure><img src="'+p+'" alt="图 5.1.1 代码区" tabindex="0" loading="lazy"><figcaption>图 5.1.1 代码区</figcaption></figure><h3 id="片上-sram" tabindex="-1"><a class="header-anchor" href="#片上-sram" aria-hidden="true">#</a> 片上 SRAM</h3><p>内部 SRAM 区的大小是 512MB，用于让芯片制造商连接片上的 SRAM，这个区通过系统总线来访问。</p><p>在这个区的下部，有一个 1MB 的区间，被称为“位带区”。该位带区还有一个对应的、 32MB 的“位带别名(alias)区”。位带区对应的是最低的 1MB 地址范围[<code>0x20000000</code>:<code>0x20100000</code>]，而位带别名区里面的每个字（一个字 32 位，4 字节）对应位带区的一个比特。访问位带区需要通过访问位带别名区进行访问，。位带操作只适用于数据访问，不适用于取指。</p><figure><img src="'+c+'" alt="图 5.1.2 片上 sram 区" tabindex="0" loading="lazy"><figcaption>图 5.1.2 片上 sram 区</figcaption></figure><p>通过位带的功能，可以把多个布尔型数据打包在单一的字中，却依然可以从位带别名区中，像访问普通内存一样地使用它们。</p><p>位带别名区中的访问操作是原子的，消灭了传统的“读－改－写”三步曲。</p><h3 id="片上外设" tabindex="-1"><a class="header-anchor" href="#片上外设" aria-hidden="true">#</a> 片上外设</h3><p>这个区中也有一条 32MB 的位带别名，以便于快捷地访问外设寄存器，用法与内部 SRAM 区中的位带相同。例如，可以方便地访问各种控制位和状态位。要注意的是，外设区内不允许执行指令。</p><figure><img src="'+o+'" alt="图 5.1.3 片上外设区" tabindex="0" loading="lazy"><figcaption>图 5.1.3 片上外设区</figcaption></figure><h3 id="片外-ram-和-片外-ram" tabindex="-1"><a class="header-anchor" href="#片外-ram-和-片外-ram" aria-hidden="true">#</a> 片外 RAM 和 片外 RAM</h3><p>两个 1GB 的范围，分别用于连接外部 RAM 和外部设备，它们之中没有位带。两者的区别在于外部 RAM 区允许执行指令，而外部设备区则不允许。</p><h3 id="最后-0-5gb-的隐秘地带" tabindex="-1"><a class="header-anchor" href="#最后-0-5gb-的隐秘地带" aria-hidden="true">#</a> 最后 0.5GB 的隐秘地带</h3><p>包括了</p><ul><li><p>系统级组件</p></li><li><p>内部私有外设总线</p><ul><li>嵌套向量中断控制器（NVIC）</li><li>闪存地址重载及断点单元（FPB）</li><li>仪器化跟踪宏单元（ITM）</li><li>数据观察点单元（DWT）</li></ul></li><li><p>外部私有外设总线</p><ul><li>嵌入式跟踪红单元（ETM）</li><li>跟踪端口接口单元（TPIU）</li></ul></li><li><p>MCU 厂商定义的系统外设</p></li></ul><p>私有外设总线有两条：</p><ul><li>AHB 私有外设总线，只用于 CM3 内部的 AHB 外设，它们是： NVIC, FPB, DWT 和 ITM；</li><li>APB 私有外设总线，既用于 CM3 内部的 APB 设备，也用于外部设备（这里的“外部”是对内核而言）。</li></ul><p>CM3 允许器件制造商再添加一些片上 APB 外设到 APB 私有总线上，它们通过 APB 接口来访问。</p><p>CM3 中的 MPU 是选配的，由芯片制造商决定是否配上。</p><h2 id="内存访问属性" tabindex="-1"><a class="header-anchor" href="#内存访问属性" aria-hidden="true">#</a> 内存访问属性</h2><p>内存的 4 种访问属性：</p><ul><li>缓冲</li><li>缓存</li><li>执行</li><li>共享</li></ul><p>如果配了 MPU，则可以通过它配置不同的存储区，并且覆盖缺省的访问属性。 CM3 片内没有配备缓存，也没有缓存控制器，但是允许在外部添加缓存。</p><p>地址空间可以通过另一种方式分为 8 个 512MB 等份：</p><ol><li>代码区（<code>0x00000000</code>- <code>0x1FFFFFFF</code>）； <ul><li>可执行；</li><li>缓存属性为不可缓存；</li><li>此区亦允许布设数据存储器。在此区上的数据操作是通过数据总线接口的（估计读数据使用D-Code，写数据使用 System），且在此区上的写操作是缓冲的。</li></ul></li><li>SRAM 区（<code>0x20000000</code> – <code>0x3FFFFFFF</code>）； <ul><li>可执行；</li><li>写操作是缓冲的，并且可以选择 WB-WA(Write Back, Write Allocated) 缓存属性。</li></ul></li><li>片上外设区(<code>0x40000000</code> – <code>0x5FFFFFFF</code>) ； <ul><li>不可执行；</li><li>不可缓存。</li></ul></li><li>外部 RAM 区的前半段（<code>0x60000000</code> - <code>0x7FFFFFFF</code>），该区可用于布设片上 RAM 或片外 RAM ； <ul><li>可执行；</li><li>可缓存（缓存属性为 WB-WA） 。</li></ul></li><li>外部 RAM 区的后半段（<code>0x80000000</code> – <code>0x9FFFFFFF</code>）； <ul><li>可执行；</li><li>不可缓存；</li></ul></li><li>外部外设区的前半段(<code>0xA0000000</code> – <code>0xBFFFFFFF</code>) ； <ul><li>不可执行；</li><li>不可缓冲，需要严格按顺序操作（用于片外外设的寄存器，也用于多核系统中的共享内存。）；</li></ul></li><li>外部外设区的后半段(<code>0xC0000000</code> – <code>0xDFFFFFFF</code>) ，目前与前半段的功能完全一致 ；</li><li>系统区(<code>0xE0000000</code> – <code>0xFFFFFFFF</code>) ； <ul><li>此区是私有外设和供应商指定功能区。此区不可执行代码；</li><li>系统区涉及到很多关键部位，因此访问都是严格序列化的（不可缓存，不可缓冲） ；</li><li>供应商指定功能区则是可以缓存和缓冲的。</li></ul></li></ol><h2 id="默认内存访问权限" tabindex="-1"><a class="header-anchor" href="#默认内存访问权限" aria-hidden="true">#</a> 默认内存访问权限</h2><p>CM3 有一个缺省的存储访问许可，它能防止使用户代码访问系统控制存储空间，保护 NVIC、 MPU 等关键部件。缺省访问许可在下列条件时生效：</p><ul><li><p>没有配备 MPU</p></li><li><p>配备了 MPU，但是 MPU 被使能</p></li></ul><figure><img src="'+r+'" alt="图5.4.1 默认内存访问权限" tabindex="0" loading="lazy"><figcaption>图5.4.1 默认内存访问权限</figcaption></figure><figure><img src="'+m+'" alt="图5.4.2 默认内存访问权限" tabindex="0" loading="lazy"><figcaption>图5.4.2 默认内存访问权限</figcaption></figure><h2 id="位带操作" tabindex="-1"><a class="header-anchor" href="#位带操作" aria-hidden="true">#</a> 位带操作</h2><p>支持了位带操作后，可以使用普通的加载/存储指令来对单一的比特进行读写。在 CM3 中，有两个区中实现了位带。其中一个是 SRAM 区的最低 1MB 范围，第二个则是片内外设区的最低 1MB 范围。</p><figure><img src="'+d+'" alt="图 5.5.1 位带区与位带别名区的膨胀关系图 A" tabindex="0" loading="lazy"><figcaption>图 5.5.1 位带区与位带别名区的膨胀关系图 A</figcaption></figure><p>举例：欲设置地址 <code>0x2000000</code> 中的比特 2，则使用位带操作的设置过程如下图所示：</p><figure><img src="'+u+'" alt="图 5.5.2 写数据到位带别名区" tabindex="0" loading="lazy"><figcaption>图 5.5.2 写数据到位带别名区</figcaption></figure><figure><img src="'+h+'" alt="图 5.5.3 位带操作与普通操作的对比，在汇编程序的角度上" tabindex="0" loading="lazy"><figcaption>图 5.5.3 位带操作与普通操作的对比，在汇编程序的角度上</figcaption></figure><figure><img src="'+g+'" alt="图 5.5.4 从位带别名区中读取比特" tabindex="0" loading="lazy"><figcaption>图 5.5.4 从位带别名区中读取比特</figcaption></figure><figure><img src="'+k+'" alt="图 5.5.5 读取比特时传统方法与位带方法的比较" tabindex="0" loading="lazy"><figcaption>图 5.5.5 读取比特时传统方法与位带方法的比较</figcaption></figure><p>尽管 Cortex-M3 没有用于操作比特的特殊指令，访问被定义为 bit-band 的内存区域会被自动转换为 bit-band 操作。</p><p>CM3 使用如下术语来表示位带存储的相关地址</p><ul><li><p>位带区： 支持位带操作的地址区</p></li><li><p>位带别名： 对别名地址的访问最终会变换成对位带区的访问（注意：这中途有一个地址映射过程）</p></li></ul><p>在位带区中，每个比特都映射到别名地址区的一个字——这是个只有 LSB 才有效的字。当一个别名地址被访问时，会先把该地址变换成位带地址。</p><ul><li>对于读操作，读取位带地址中的一个字，再把需要的位右移到 LSB，并把 LSB 返回。</li><li>对于写操作，把需要写的位左移至对应的位序号处，然后执行一个原子的“读－改－写”过程。</li></ul><p>支持位带操作的两个内存区的范围是：</p>',55),R=s("ul",null,[s("li",null,[s("p",null,[s("code",null,"0x20000000"),a("-"),s("code",null,"0x200FFFFF"),a("（SRAM 区中的最低 1MB）")]),s("p",null,"对于 SRAM 位带区的某个比特，记它所在字节地址为 A,位序号为 n(0<=n<=7)，则该比特在别名区的地址为："),s("p",null,[s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mtable",{rowspacing:"0.25em",columnalign:"right left",columnspacing:"0em"},[s("mtr",null,[s("mtd",null,[s("mstyle",{scriptlevel:"0",displaystyle:"true"},[s("mrow",null,[s("mi",null,"A"),s("mi",null,"l"),s("mi",null,"i"),s("mi",null,"a"),s("mi",null,"s"),s("mi",null,"A"),s("mi",null,"d"),s("mi",null,"d"),s("mi",null,"r")])])]),s("mtd",null,[s("mstyle",{scriptlevel:"0",displaystyle:"true"},[s("mrow",null,[s("mrow"),s("mtext",null,"＝0x22000000"),s("mo",null,"+"),s("mo",{stretchy:"false"},"("),s("mo",{stretchy:"false"},"("),s("mi",null,"A"),s("mo",null,"−"),s("mtext",null,"0x20000000"),s("mo",{stretchy:"false"},")"),s("mo",null,"×"),s("mn",null,"8"),s("mo",null,"+"),s("mi",null,"n"),s("mo",{stretchy:"false"},")"),s("mo",null,"×"),s("mn",null,"4")])])])]),s("mtr",null,[s("mtd",null,[s("mstyle",{scriptlevel:"0",displaystyle:"true"},[s("mrow")])]),s("mtd",null,[s("mstyle",{scriptlevel:"0",displaystyle:"true"},[s("mrow",null,[s("mrow"),s("mo",null,"="),s("mtext",null,"0x22000000"),s("mo",null,"+"),s("mo",{stretchy:"false"},"("),s("mi",null,"A"),s("mo",null,"−"),s("mtext",null,"0x20000000"),s("mo",{stretchy:"false"},")"),s("mo",null,"×"),s("mn",null,"32"),s("mo",null,"+"),s("mi",null,"n"),s("mo",null,"×"),s("mn",null,"4")])])])])]),s("annotation",{encoding:"application/x-tex"},"\\begin{aligned}AliasAddr&＝\\text{0x22000000}+((A-\\text{0x20000000})\\times8+n)\\times4\\\\&=\\text{0x22000000}+(A-\\text{0x20000000})\\times32+n\\times4\\end{aligned}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"3em","vertical-align":"-1.25em"}}),s("span",{class:"mord"},[s("span",{class:"mtable"},[s("span",{class:"col-align-r"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"1.75em"}},[s("span",{style:{top:"-3.91em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"A"),s("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),s("span",{class:"mord mathnormal"},"ia"),s("span",{class:"mord mathnormal"},"s"),s("span",{class:"mord mathnormal"},"A"),s("span",{class:"mord mathnormal"},"dd"),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"r")])]),s("span",{style:{top:"-2.41em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"mord"})])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"1.25em"}},[s("span")])])])]),s("span",{class:"col-align-l"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"1.75em"}},[s("span",{style:{top:"-3.91em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"mord"},[s("span",{class:"mord"}),s("span",{class:"mord cjk_fallback"},"＝"),s("span",{class:"mord text"},[s("span",{class:"mord"},"0x22000000")]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mopen"},"(("),s("span",{class:"mord mathnormal"},"A"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"−"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mord text"},[s("span",{class:"mord"},"0x20000000")]),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"×"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mord"},"8"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"×"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mord"},"4")])]),s("span",{style:{top:"-2.41em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"mord"},[s("span",{class:"mord"}),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mord text"},[s("span",{class:"mord"},"0x22000000")]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"A"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"−"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mord text"},[s("span",{class:"mord"},"0x20000000")]),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"×"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mord"},"32"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"×"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mord"},"4")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"1.25em"}},[s("span")])])])])])])])])])])]),s("li",null,[s("p",null,[s("code",null,"0x40000000"),a("-"),s("code",null,"0x400FFFFF"),a("（片上外设区中的最低 1MB）")]),s("p",null,"对于片上外设位带区的某个比特，记它所在字节的地址为 A,位序号为 n(0<=n<=7)，则该比特在别名区的地址为："),s("p",null,[s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mtable",{rowspacing:"0.25em",columnalign:"right left",columnspacing:"0em"},[s("mtr",null,[s("mtd",null,[s("mstyle",{scriptlevel:"0",displaystyle:"true"},[s("mrow",null,[s("mi",null,"A"),s("mi",null,"l"),s("mi",null,"i"),s("mi",null,"a"),s("mi",null,"s"),s("mi",null,"A"),s("mi",null,"d"),s("mi",null,"d"),s("mi",null,"r")])])]),s("mtd",null,[s("mstyle",{scriptlevel:"0",displaystyle:"true"},[s("mrow",null,[s("mrow"),s("mtext",null,"＝0x42000000"),s("mo",null,"+"),s("mo",{stretchy:"false"},"("),s("mo",{stretchy:"false"},"("),s("mi",null,"A"),s("mo",null,"−"),s("mtext",null,"0x40000000"),s("mo",{stretchy:"false"},")"),s("mo",null,"×"),s("mn",null,"8"),s("mo",null,"+"),s("mi",null,"n"),s("mo",{stretchy:"false"},")"),s("mo",null,"×"),s("mn",null,"4")])])])]),s("mtr",null,[s("mtd",null,[s("mstyle",{scriptlevel:"0",displaystyle:"true"},[s("mrow")])]),s("mtd",null,[s("mstyle",{scriptlevel:"0",displaystyle:"true"},[s("mrow",null,[s("mrow"),s("mo",null,"="),s("mtext",null,"0x42000000"),s("mo",null,"+"),s("mo",{stretchy:"false"},"("),s("mi",null,"A"),s("mo",null,"−"),s("mtext",null,"0x40000000"),s("mo",{stretchy:"false"},")"),s("mo",null,"×"),s("mn",null,"32"),s("mo",null,"+"),s("mi",null,"n"),s("mo",null,"×"),s("mn",null,"4")])])])])]),s("annotation",{encoding:"application/x-tex"},"\\begin{aligned}AliasAddr &＝ \\text{0x42000000} + ((A-\\text{0x40000000})\\times8+n)\\times4 \\\\&= \\text{0x42000000} + (A-\\text{0x40000000})\\times32 + n\\times4\\end{aligned}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"3em","vertical-align":"-1.25em"}}),s("span",{class:"mord"},[s("span",{class:"mtable"},[s("span",{class:"col-align-r"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"1.75em"}},[s("span",{style:{top:"-3.91em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"A"),s("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),s("span",{class:"mord mathnormal"},"ia"),s("span",{class:"mord mathnormal"},"s"),s("span",{class:"mord mathnormal"},"A"),s("span",{class:"mord mathnormal"},"dd"),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"r")])]),s("span",{style:{top:"-2.41em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"mord"})])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"1.25em"}},[s("span")])])])]),s("span",{class:"col-align-l"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"1.75em"}},[s("span",{style:{top:"-3.91em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"mord"},[s("span",{class:"mord"}),s("span",{class:"mord cjk_fallback"},"＝"),s("span",{class:"mord text"},[s("span",{class:"mord"},"0x42000000")]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mopen"},"(("),s("span",{class:"mord mathnormal"},"A"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"−"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mord text"},[s("span",{class:"mord"},"0x40000000")]),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"×"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mord"},"8"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"×"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mord"},"4")])]),s("span",{style:{top:"-2.41em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"mord"},[s("span",{class:"mord"}),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mord text"},[s("span",{class:"mord"},"0x42000000")]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"A"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"−"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mord text"},[s("span",{class:"mord"},"0x40000000")]),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"×"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mord"},"32"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"×"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mord"},"4")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"1.25em"}},[s("span")])])])])])])])])])])])],-1),v=n(`<p>上式中，“4”表示一个字为 4 个字节，“8”表示一个字节中有 8 个比特。</p><p>这里再不嫌啰嗦地举一个例子：</p><ol><li><p>在地址 <code>0x20000000</code> 处写入 <code>0x3355AACC</code></p></li><li><p>读取地址 <code>0x22000008</code>。本次读访问将读取 <code>0x20000000</code>，并提取比特 2，值为 1。</p></li><li><p>往地址 <code>0x22000008</code> 处写 0。本次操作将被映射成对地址 <code>0x20000000</code> 的“读－改－写”操作（原子的），把比特 2 清 0。</p></li><li><p>现在再读取 0x20000000，将返回 0x3355AAC8（bit[2] 已清零）。</p></li></ol><p>位带别名区的字只有 LSB 有意义。另外，在访问位带别名区时，不管使用哪一种长度的数据传送指令（字/半字/字节），都把地址对齐到字的边界上，否则会产生不可预料的结果。</p><h3 id="位带操作的优越性" tabindex="-1"><a class="header-anchor" href="#位带操作的优越性" aria-hidden="true">#</a> 位带操作的优越性</h3><p>位带操作有什么优越性呢？最容易想到的就是通过 GPIO 的管脚来单独控制每盏 LED 的点亮与熄灭。另一方面，也对操作串行接口器件提供了很大的方便 。</p><p>位带操作还能用来化简跳转的判断。当跳转依据是某个位时，以前必须这样做：</p><ul><li>读取整个寄存器</li><li>掩蔽不需要的位</li><li>比较并跳转</li></ul><p>现在只需：</p><ul><li>从位带别名区读取状态位</li><li>比较并跳转</li></ul><p>使代码更简洁，这只是位带操作优越性的初等体现。<u>位带操作还有一个重要的好处是在多任务中，用于实现共享资源在任务间的“互锁”访问。多任务的共享资源必须满足一次只有一个任务访问它——亦即所谓的“原子操作”</u>。以前的读－改－写需要 3 条指令，导致这中间留有两个能被中断的空当。通过使用 CM3 的位带操作，就可以消灭上例中的紊乱危象。 CM3 把这个“读－改－写”做成一个硬件级别支持的原子操作，不能被中断。</p><h3 id="其它数据长度上的位带操作" tabindex="-1"><a class="header-anchor" href="#其它数据长度上的位带操作" aria-hidden="true">#</a> 其它数据长度上的位带操作</h3><p>位带操作并不只限于以字为单位的传送。亦可以按半字和字节为单位传送。例如，可以使用LDRB/STRB 来以字节为长度单位去访问位带别名区，同理可用于 LDRH/STRH。但是不管用哪一个对子，都必须保证目标地址对齐到字的边界上。</p><h3 id="在-c-语言中使用位带操作" tabindex="-1"><a class="header-anchor" href="#在-c-语言中使用位带操作" aria-hidden="true">#</a> 在 C 语言中使用位带操作</h3><p>不幸的是，在 C 编译器中并没有直接支持位带操作。比如， C 编译器并不知道同一块内存能够使用不同的地址来访问，也不知道对位带别名区的访问只对 LSB 有效。欲在 C 中使用位带操作，最简单的做法就是#define 一个位带别名区的地址。 例如：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DEVICE_REG0</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">volatile</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token number">0x40000000</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DEVICE_REG0_BIT0</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">volatile</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token number">0x42000000</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DEVICE_REG0_BIT1</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">volatile</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token number">0x42000004</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>

<span class="token operator">*</span>DEVICE_REG0 <span class="token operator">=</span> <span class="token number">0xAB</span><span class="token punctuation">;</span> 				<span class="token comment">// 使用正常地址访问寄存器</span>
<span class="token operator">*</span>DEVICE_REG0 <span class="token operator">=</span> <span class="token operator">*</span>DEVICE_REG0 <span class="token operator">|</span> <span class="token number">0x2</span><span class="token punctuation">;</span> 	<span class="token comment">// 使用传统方法设置 bit1</span>
<span class="token operator">*</span>DEVICE_REG0_BIT1 <span class="token operator">=</span> <span class="token number">0x1</span><span class="token punctuation">;</span> 			<span class="token comment">// 通过位带别名地址设置 bit1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为简化位带操作，也可以定义一些宏。比如，我们可以建立一个把“位带地址＋位序号”转换成别名地址的宏，再建立一个把别名地址转换成指针类型的宏：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">//把“位带地址＋位序号”转换成别名地址的宏</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">BITBAND</span><span class="token expression"><span class="token punctuation">(</span>addr<span class="token punctuation">,</span> bitnum<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>addr <span class="token operator">&amp;</span> <span class="token number">0xF0000000</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">0x2000000</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token punctuation">(</span>addr <span class="token operator">&amp;</span></span></span>
<span class="token number">0xFFFFF</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token punctuation">(</span>bitnum<span class="token operator">&lt;&lt;</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">//把该地址转换成一个指针</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">MEM_ADDR</span><span class="token expression"><span class="token punctuation">(</span>addr<span class="token punctuation">)</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">volatile</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>adr<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
    
<span class="token function">MEM_ADDR</span><span class="token punctuation">(</span>DEVICE_REG0<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0xAB</span><span class="token punctuation">;</span> 						<span class="token comment">// 使用正常地址访问寄存器</span>
<span class="token function">MEM_ADDR</span><span class="token punctuation">(</span>DEVICE_REG0<span class="token punctuation">)</span><span class="token operator">=</span> <span class="token function">MEM_ADDR</span><span class="token punctuation">(</span>DEVICE_REG0<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">0x2</span><span class="token punctuation">;</span> <span class="token comment">// 传统做法</span>
<span class="token function">MEM_ADDR</span><span class="token punctuation">(</span><span class="token function">BITBAND</span><span class="token punctuation">(</span>DEVICE_REG0<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0x1</span><span class="token punctuation">;</span> 			<span class="token comment">// 使用位带别名地址</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意：当使用位带功能时，要访问的变量必须用 volatile 来定义。因为 C 编译器并不知道同一个比特可以有两个地址。所以就要通过 volatile，使得编译器每次都如实地把新数值写入存储器，而不再会出于优化的考虑，在中途使用寄存器来操作数据的复本，直到最后才把复本写回— —这会导致按不同的方式访问同一个位会得到不一致的结果。</p><h2 id="非对齐数据传输" tabindex="-1"><a class="header-anchor" href="#非对齐数据传输" aria-hidden="true">#</a> 非对齐数据传输</h2><p>CM3 支持在单一的访问中使用非（地址）对齐的传送，数据存储器的访问无需对齐。在以前， ARM 处理器只允许对齐的数据传送。这种对齐是说：</p><ul><li>以字为单位的传送，其地址的最低两位必须是0；</li><li>以半字为单位的传送，其地址的 LSB 必须是 0；</li><li>以字节为单位的传送则无所谓对不对齐。</li></ul><p>任何一个不能被 4 整除的地址都是非对齐的。而对于半字，任何不能被 2 整除的地址（也就是奇数地址）都是非对齐的。</p><p>在 CM3 中，非对齐的数据传送只发生在常规的数据传送指令中，如 LDR/LDRH/LDRSH。其它指令则不支持，包括：</p><ul><li>多个数据的加载/存储(LDM/STM)</li><li>堆栈操作 PUSH/POP</li><li>互斥访问 （LDREX/STREX）。如果非对齐会导致一个用法 fault。</li><li>位带操作。因为只有 LSB 有效，非对齐的访问会导致不可预料的结果。</li></ul><p>事实上，在内部是把非对齐的访问转换成若干个对齐的访问的，这种转换动作由处理器总线单元来完成。这个转换过程对程序员是透明的，因此写程序时不必操心。</p><p>但是，因为它通过若干个对齐的访问来实现一个非对齐的访问， 会需要更多的总线周期。为此，可以编程 NVIC，使之监督地址对齐。当发现非对齐访问时触发一个 fault。具体的办法是设置“配置控制寄存器”中的 UNALIGN_TRP 位。这样，在整个调试期间就可以保证非对齐访问能当场被发现。</p><h2 id="互斥访问" tabindex="-1"><a class="header-anchor" href="#互斥访问" aria-hidden="true">#</a> 互斥访问</h2><p>细心的读者可能会发现， CM3 中没有类似“SWP”的指令。在传统的 ARM 处理器中， SWP 指令是实现互斥体所必需的。到了 CM3，由所谓的互斥访问取代了 SWP 指令，以实现更加老练的共享资源访问保护机制。</p><p>在新版的 ARM 处理器中，读/写访问往往使用不同的总线，导致 SWP 无法再保证操作的原子性，因为只有在同一条总线上的读/写能实现一个互锁的传送。</p><p>因此，互锁传送必须用另外的机制实现，这就引入了“互斥访问”。互斥访问的理念同 SWP 非常相似，不同点在于：在互斥访问操作下，允许互斥体所在的地址被其它总线 master 访问，也允许被其它运行在本机上的任务访问，但是 CM3能够“驳回”有可能导致竞态条件的互斥写操作。</p><p>互 斥 访 问 分 为 加 载 和 存 储 ， 相 应 的 指 令 对 子 为 <code>LDREX/STREX</code>, <code>LDREXH/STREXH</code>, <code>LDREXB/STREXB</code>，分别对应于字/半字/字节。为了介绍方便，以 <code>LDREX/STREX</code> 为例讲述它们的使用方式。</p><p><code>LDREX/STREX</code> 的语法格式为：</p><ul><li><code>LDREX Rxf, [Rn, #offset]</code></li><li><code>STREX Rd, Rxf, [Rn, #offset]</code></li></ul><p><code>LDREX</code> 的语法同 <code>LDR</code> 相同，而 <code>STREX</code> 则不同。 <code>STREX</code> 指令的执行是可以被“驳回”的：</p><ul><li>当处理器同意执行 <code>STREX</code> 时， Rxf 的值被存储到(Rn+offset)处，并且把 Rd 的值更新为 0；</li><li>但若处理器驳回了 <code>STREX</code> 的执行，则不会发生存储动作，并且把 Rd 的值更新为 1。</li></ul><div class="hint-container warning"><p class="hint-container-title">注意</p><p>当遇到 <code>STREX</code> 指令时，仅当在它之前执行过 <code>LDREX</code> 指令，且在最近的一条 <code>LDREX</code> 指令执行后，没有执行过其它的 <code>STR/STREX</code> 指令，才允许执行本条 <code>STREX</code> 指令——也就是说只有在 <code>LDREX</code> 执行后，从时间上与之距离最近的一条 <code>STREX</code> 才能成功执行。</p></div><p>这种最严格的规则也是最容易实现的规则。在 CM3 的技术参考手册中，推荐实现者标记出一段有限的地址，只在这段地址中适用互斥访问的规则，而不要对所有 4GB 都限制住。这段地址通常是从 <code>LDREX</code> 指令族给出的地址开始，长度在 16 字节至 4K 字节范围内。但芯片制造商可能更倾向严格的规则。</p><p><strong>在使用互斥访问时， <code>LDREX/STREX</code> 必须成对使用。</strong></p><p>为什么这种有条件的驳回可以避免紊乱危象呢？让我们举个简单的例子来演示。这个例子由主程序和一个中断服务例程组成。主程序尝试对(R0)自增两次，中断服务例程则把(R0).5</p><p>置位。计(R0)的初始值为 0。</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>MainProgram
    ;第一次互斥自增
TryInc1st
    LDREX r2, [R0]
    ADD r2, #1
    ;执行到这里时，处理器接收到外中断 3 请求，于是转到其中断服务例程 ISREx3 中
    STREX R1, R2, [R0] ; STREX 被驳回， R1=1， (R0)=0x20
TryInc2nd
    ;第二次互斥自增
    LDREX r2, [R0]
    ADD r2, #1
    STREX R1, R2, [R0] ; STREX 得到执行， R1=0， (R0)=0x21
    …
ISREx3
    ;处理器已经自动把 R0-R3, R12, LR, PC, PSR 压入栈
    LDR R2, [R0]
    ORR R2, #0x20
    STR R2, [R0] ;在 ISREx3 中设置了(r0)的 Bit2
    BX LR ;返回时，处理器会自动把 R0-R3,R12,LR,PC,PSR 弹出堆栈
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上例中，主程序在即将执行第一条 <code>STREX</code> 时，产生了外部中断#3。处理器打断主程序的执行，进入其服务例程 ISREx3，它对(R0)执行了一个写操作(STR)，因此在 ISRExt3 返回后， <code>STREX</code> 不再是 <code>LDREX</code> 执行后的第一条存储指令，故而被驳回。从而 ISREx3 对(R0)的改动就不会遭到破坏。随后主程序再次尝试自增运算，这一次在 STREX 执行前没有其它任何形式的存储指令，所有 <code>STREX</code> 成功执行。</p><p>如果主程序使用普通的 STR 会怎么样呢？对于第一次自增，主程序的 R2=1，于是执行后(R0)=1，结果，中断服务程序对(R0)的改动在此丢失！</p><p><code>LDREX/STREX</code> 的工作原理其实很简单。仍然以上一段程序为例：当执行了 <code>LDREX</code> 后，处理器会在内部标记出一段地址。原则上，这段地址从 R0 开始，范围由芯片制造商定义。技术手册推荐的范围是在 4 字节至 4KB 之间，但是很多粗线条的实现会标记整个 4GB 的地址。在标记以后， 对于第一个执行到的 <code>STR/STREX</code> 指令，只要其存储的地址落在标记范围内，就会清除此标记（对于整个4GB 地址都被标记的情况，则任何存储指令都会清除此标记）。如果先后执行了两次 <code>LDREX</code>，则以后一个 <code>LDREX</code> 标记的地址为准。</p><p>执行 <code>STREX</code> 时，会先检查有没有做出过标记，如果有，还要检查存储地址是否落在标记范围内。只有通过了这两个关卡， <code>STREX</code> 才会执行。否则，就驳回 <code>STREX</code>。</p><p>当使用互斥访问时，在 CM3 总线接口上的内部写缓冲会被旁路，即使是 MPU 规定此区是可以缓冲的也不行。这保证了互斥体的更新总能在第一时间内完成，从而保证数据在各个总线主机(master)之间是一致的。 So 系统的设计师如果设计多核系统，则必须保证各核之间看到的数据也是一致的。</p><h2 id="端模式" tabindex="-1"><a class="header-anchor" href="#端模式" aria-hidden="true">#</a> 端模式</h2><p>CM3 支持 both 小端模式和大端模式。在绝大多数情况下，基于 CM3 的单片机都使用小端模式— —为了避免不必要的麻烦，在这里推荐读者清一色地使用小端模式。</p><p>CM3 中对大端模式的定义还与 ARM7 的不同（小端的定义都是相同的）。在 ARM7 中，大端的方式被称为“字不变大端”，而在 CM3 中，使用的是“字节不变大端”。</p><p>请注意：在 AHB 总线上的 BE-8 模式下，数据字节 lane 的传送格式是与小端模式一致的。</p><p>在 CM3 中，是在复位时确定使用哪种端模式的，且运行时不得更改。</p><p>使用小端的情景：</p><ul><li>指令预取永远使用小端模式；</li><li>在配置控制存储空间的访问也永远使用小端模式（包括 NVIC, FPB 等）；</li><li>外部私有总线地址区 0xE0000000 至 0xE00FFFFF 也永远使用小端模式。</li></ul>`,54),b=[y,R,v];function f(E,M){return e(),t("div",null,b)}const F=l(x,[["render",f],["__file","memory-system.html.vue"]]);export{F as default};
